/**
 * File:	modules/DnsServer.ycp
 * Package:	Configuration of dns-server
 * Summary:	Data for configuration of dns-server, input and output functions.
 * Authors:	Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of dns-server.
 * Input and output routines.
 */

{

    module "DnsServer";
    textdomain "dns-server";

    import "Progress";
    import "Report";
    import "Summary";
    import "Runlevel";

    include "dns-server/misc.ycp";
    include "dns-server/dialogs.ycp";
    include "dns-server/wizards.ycp";
    include "dns-server/helps.ycp";
    include "dns-server/options.ycp";
    include "dns-server/widgets.ycp";

    /**
      * Data was modified?
      */
    global boolean modified = false;

    /**
      * save everything, not only changed settings
      */
    global boolean save_all = false;

    /**
      * Were the zones modified?
      */
    global boolean zones_modified = false;

    /**
      * Write only, used during autoinstallation.
      * Don't run services and SuSEconfig, it's all done at one place.
      */
    global boolean write_only = false;

    /**
      * BIND version
      */
    global integer version = 0;

    /**
      * Is read allowed to ask user about BIND package to install
      * Probably to be used for command line iface
      */
    global boolean interactive_read = true;
    /**
      * hostname
      */
    global string hostname = "localhost";
    /**
      * Date (for zone files)
      */
    global string date = "";

    /**
      * DNS server settings
      */
    global map settings = $[];

    /**
      * Temporary list of zones
      */
    global list all_zones = [];

    /**
      * Temporary storage of current zone
      */
    global map current_zone = $[];

    /**
      * Temporary variable for storing original id of currently edited zone
      */
    global integer current_id = -1;

    global string displayed_settings = "settings";

    /**
      * Map of popups for CWM
      */
    global map popups = InitPopups ();

    /**
      * Map of widgets for CWM
      */
    global map widgets = InitWidgets ();

    /**
      * Read all dns-server settings
      * @return true on success
      */
    global define boolean Read() ``{

	/* DnsServer read dialog caption */
	string caption = _("Initializing DNS Server Configuration");

	integer steps = 30;

	Progress::New( caption, " ", steps, [
		// progress stage
		_("Check the environment"),
		// progress stage
		_("Read main configuration file"),
		// progress stage
		_("Read the zone files")
	    ], [
		// progress step
		_("Checking the environment..."),
		// progress step
		_("Reading main configuration file..."),
		// progress step
		_("Reading the zone files..."),
		// progress step
		_("Finished")
	    ],
	    ""
	);

	// read database
	if(UI::PollInput() == `abort) return false;
	Progress::NextStageStep (0);

	// set the local host name
	hostname = getLocalHostName ();

	// determine used BIND version
	version = getBindVersion (interactive_read);
	if (version == nil)
	{
	    // warning report
	    Report::Warning (_("Neither bind8 nor bind9 installed"));
	}

	settings["start_service"] = Runlevel::ServiceEnabled ("named");
	settings["chroot"]
	    = SCR::Read (.sysconfig.named.NAMED_RUN_CHROOTED) == "yes"
		? true
		: false;

	if(UI::PollInput() == `abort) return false;
	Progress::NextStageStep (10);

	list zone_headers = SCR::Dir (.dns.named.section);
	zone_headers = filter (`z, zone_headers,
	    ``(substring (z, 0, 4) == "zone"));
	y2milestone ("Read zone sections %1", zone_headers);

	list opt_names = SCR::Dir (.dns.named.value.options);
	if (opt_names == nil)
	    opt_names = [];
	map options = listmap (`key, opt_names, ``{
	    string val = SCR::Read (add (.dns.named.value.options, key));
	    return [key, val];
	});
	if (options == nil)
	    options = $[];
	settings["options"] = options;
	y2milestone ("Read options: %1", options);

	if(UI::PollInput() == `abort) return false;
	Progress::NextStageStep (20);

	integer zonecount = size (zone_headers);
	integer done = 0;
	list zones = maplist (`z, zone_headers, ``{
	    string zonename = regexpsub (z, ".*\"(.*)\".*", "\\1");
	    string zonetype = SCR::Read (add (add (.dns.named.value, z),
		"type"));
	    string filename = SCR::Read (add (add (.dns.named.value, z),
		"file"));
	    if (filename != nil && regexpmatch (filename, "^\".*\"$"))
		filename = regexpsub (filename, "^\"(.*)\"$", "\\1");
	    map zd = $[];
	    if (zonetype == "master")
	    {
		zd = zoneRead (zonename, filename);
	    }
	    else if (zonetype == "slave" || zonetype == "stub")
	    {
		zd["masters"] = SCR::Read (add (add (.dns.named.value, z),
		    "masters"));
	    }
	    else
	    {
		// hint, forward, many others ...
		// not supported now
		// TODO in future
	    }
	    zd["file"] = filename;
	    zd["type"] = zonetype;
	    zd["zone"] = zonename;
	    done = done + 1;
	    Progress::Step (20 + done / zonecount);
	    sleep (500);
	    return zd;
	});
	y2milestone ("All zones: %1", zones);
	settings["zones"] = zones;

	if(UI::PollInput() == `abort) return false;
	Progress::NextStageStep (30);
	// progress stage
	Progress::Title(_("Finished"));

	modified = false;
	y2milestone ("Read settings %1", settings);
	return true;
    }

    /**
      * Write all dns-server settings
      * @return true on success
      */
     global define boolean Write() ``{

	/* DnsServer read dialog caption */
	string caption = _("Saving DNS Server Configuration");

	integer zones = size (settings["zones"]:[]);
	if (zones < 1)
	    zones = 1;

	integer steps = 3 * zones;

	Progress::New(caption, " ", steps, [
		// progress stage
		_("Save the zone files"),
		//  progress stage
		_("Save main configuration file"),
		// progress stage
		_("Restart DHCP server"),
	    ], [
		// progress step
		_("Saving the zone files..."),
		// progress step
		_("Saving main configuration file..."),
		// progress step
		_("Restarting DHCP server..."),
	    ],
	    ""
	);

	// write settings
	if(UI::PollInput() == `abort) return false;
	Progress::NextStageStep (0);

	if (save_all)
	    modified = true;

	if (! modified)
	{
	    Progress::NextStageStep (3 * zones);
	    // progress stage
	    Progress::Title(_("Finished"));
	    return true;
	}


	date = getDate ();
	// be sure options are before zones
	SCR::Write (.dns.named.section.options, "");

	boolean ok = true;
	foreach (`z, settings["zones"]:[], ``{
	    ok = ok && saveZone (z);
	    Progress::NextStep ();
	});

	if(UI::PollInput() == `abort) return false;
	Progress::NextStageStep (zones);

	if (modified)
	    ok = ok &&saveGlobals ();
	if (! ok)
	    return false;

	SCR::Write (.sysconfig.named.NAMED_RUN_CHROOTED,
	    settings["chroot"]:false ? "yes" : "no");
	SCR::Write (.sysconfig.named, nil);

	if(UI::PollInput() == `abort) return false;
	Progress::NextStageStep (2 * zones);

	if (settings["start_service"]:false)
	{
	    integer ret = 0;
	    if (! write_only)
		ret = SCR::Execute (.target.bash, "/etc/init.d/named restart");
	    Runlevel::ServiceAdjust ("named", "enable");
	    if (0 != ret)
	    {
		// yes-no popup
		if (UI::YesNoPopup (_("Warning!

An error occurred while starting the DNS server.
Display the log and continue with configuration?
")))
		{
		    showLogPopup (nil);
		    return nil;
		}
		return false;
	    }
	}
	else
	{
	    if (! write_only)
		SCR::Execute (.target.bash, "/etc/init.d/named stop");
	    Runlevel::ServiceAdjust ("named", "disable");
	}

	if(UI::PollInput() == `abort) return false;
	Progress::NextStageStep (3 * zones);

	// progress stage
        Progress::Title(_("Finished"));

	return true;
    }

    /**
      * Get all dns-server settings from the first parameter
      * (For use by autoinstallation.)
      * @param imp_settings The YCP structure to be imported.
      * @return boolean True on success
      */
    global define boolean Import (map imp_settings) ``{
	settings = imp_settings;
	modified = true;
	zones_modified = true;
	save_all = true;
	return true;
    }

    /**
      * Dump the dns-server settings to a single map
      * (For use by autoinstallation.)
      * @return map Dumped settings (later acceptable by Import ())
      */
    global define map Export () ``{
	return settings;
    }

    /**
      * Create a textual summary and a list of unconfigured cards
      * @return list summary of the current configuration
      */
    global define list Summary() ``{
	map zone_types = $[
	    // type of zone to be used in summary
	    "master" : _("master"),
	    // type of zone to be used in summary
	    "slave" : _("slave"),
	    // type of zone to be used in summary
	    "stub" : _("stub"),
	    // type of zone to be used in summary
	    "hint" : _("hint"),
	    // type of zone to be used in summary
	    "forward" : _("forward"),
	];
	string start_string = settings["start_service"]:false
	    // summary string
	    ? _("The DNS server starts when booting the system.")
	    // summary string
	    : _("The DNS server does not start when booting the system.");
	list(list(string)) zones = maplist (`z, settings["zones"]:[], ``(
	    [z["zone"]:"", z["type"]:""]
	));
	zones = filter (`z, zones, ``(z[0]:"" != ""));
	list(string) zones_disp = maplist (`z, zones, ``(
	    z[1]:"" != ""
		? sformat ("%1 (%2)", z[0]:"", zone_types[(z[1]:"")]:(z[1]:""))
		: z[0]:""
	));
	// summary string, %1 is list of DNS zones (their names)
	string zones_string = sformat (_("Configured Zones: %1"),
	    mergestring (zones_disp, ", "));
	list ret = [ start_string, zones_string ];
	return ret;
    }

/* EOF */
}
