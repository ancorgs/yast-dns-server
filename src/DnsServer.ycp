/**
 * File:	modules/DnsServer.ycp
 * Package:	Configuration of dns-server
 * Summary:	Data for configuration of dns-server, input and output functions.
 * Authors:	Jiri Srain <jsrain@suse.cz>
 *
 * $Id$
 *
 * Representation of the configuration of dns-server.
 * Input and output routines.
 */

{

    module "DnsServer";
    textdomain "dns-server";

    import "Progress";
    import "Report";
    import "Summary";
    import "Runlevel";

    include "dns-server/misc.ycp";
    include "dns-server/dialogs.ycp";
    include "dns-server/wizards.ycp";
    include "dns-server/helps.ycp";
    include "dns-server/popups.ycp";
    include "dns-server/widgets.ycp";

    /**
     * Data was modified?
     */
    global boolean modified = false;

    /**
      * Write only, used during autoinstallation.
      * Don't run services and SuSEconfig, it's all done at one place.
      */
    global boolean write_only = false;

    /**
      * Shall the dns server be started?
      */
    global boolean start_dns = false;

    /**
      * BIND version
      */
    global integer version = 0;

    /**
      * Is read allowed to ask user about BIND package to install
      * Probably to be used for command line iface
      */
    global boolean interactive_read = true;
    /**
      * hostname
      */
    global string hostname = "localhost";
    /**
      * Date (for zone files)
      */
    global string date = "";

    /**
      * DNS server settings
      */
    global map settings = $[];

    /**
      * Map of popups for CWM
      */
    global map popups = InitPopups ();

    /**
      * Map of widgets for CWM
      */
    global map widgets = InitWidgets ();

    /**
      * Read all dns-server settings
      * @return true on success
      */
    global define boolean Read() ``{

	/* DnsServer read dialog caption */
	string caption = _("Initializing DNS server configuration");

	integer steps = 30;

	Progress::New( caption, " ", steps, [
		// progress stage
		_("Check the environment"),
		// progress stage
		_("Read main configuration file"),
		// progress stage
		_("Read the zone files")
	    ], [
		// progress step
		_("Checking the environment..."),
		// progress step
		_("Reading main configuration file..."),
		// progress step
		_("Reading the zone files..."),
		// progress step
		_("Finished")
	    ],
	    ""
	);

	// read database
	if(UI::PollInput() == `abort) return false;
	Progress::NextStageStep (0);

	// set the local host name
	hostname = getLocalHostName ();

	// determine used BIND version
	version = getBindVersion (interactive_read);
	if (version == nil)
	{
	    Report::Error (_("Install bind8 or bind9 first"));
	    return false;
	}

	if(UI::PollInput() == `abort) return false;
	Progress::NextStageStep (10);

	list zone_headers = SCR::Dir (.dns.named.section);
	zone_headers = filter (`z, zone_headers,
	    ``(substring (z, 0, 4) == "zone"));
	y2milestone ("Read zone sections %1", zone_headers);

	list opt_names = SCR::Dir (.dns.named.value.options);
	map options = listmap (`key, opt_names, ``{
	    string val = SCR::Read (add (.dns.named.value.options, key));
	    return [key, val];
	});
	settings["options"] = options;
	y2milestone ("Read options: %1", options);

	if(UI::PollInput() == `abort) return false;
	Progress::NextStageStep (20);

	integer zonecount = size (zone_headers);
	integer done = 0;
	list zones = maplist (`z, zone_headers, ``{
	    string zonename = regexpsub (z, ".*\"(.*)\".*", "\\1");
	    string zonetype = SCR::Read (add (add (.dns.named.value, z),
		"type"));
	    string filename = SCR::Read (add (add (.dns.named.value, z),
		"file"));
	    if (regexpmatch (filename, "^\".*\"$"))
		filename = regexpsub (filename, "^\"(.*)\"$", "\\1");
	    map zd = $[];
	    if (zonetype == "master")
	    {
		zd = zoneRead (zonename, filename);
	    }
	    else if (zonetype == "slave" || zonetype == "stub")
	    {
		zd["masters"] = SCR::Read (add (add (.dns.named.value, z),
		    "masters"));
	    }
	    else
	    {
		// hint, forward, many others ...
		// not supported now
		// TODO in future
	    }
	    zd = $[ "file" : filename ];
	    zd["type"] = zonetype;
	    zd["zone"] = zonename;
	    done = done + 1;
	    Progress::Step (20 + done / zonecount);
	    sleep (500);
	    return zd;
	});
	y2milestone ("All zones: %1", zones);
	settings["zones"] = zones;

	if(UI::PollInput() == `abort) return false;
	Progress::NextStageStep (30);
	// progress stage
	Progress::Title(_("Finished"));

	modified = false;
	y2milestone ("Read settings %1", settings);
	return true;
    }

    /**
      * Write all dns-server settings
      * @return true on success
      */
     global define boolean Write() ``{

	/* DnsServer read dialog caption */
	string caption = _("Saving DNS server configuration");

	integer zones = size (settings["zones"]:[]);
	if (zones < 1)
	    zones = 1;

	integer steps = 3 * zones;

	Progress::New(caption, " ", steps, [
		// progress stage
		_("Save the zone files"),
		//  progress stage
		_("Save main configuration file"),
		// progress stage
		_("Restart DHCP server"),
	    ], [
		// progress step
		_("Saving the zone files"),
		// progress step
		_("Saving main configuration file..."),
		// progress step
		_("Restarting DHCP server"),
	    ],
	    ""
	);

	// write settings
	if(UI::PollInput() == `abort) return false;
	Progress::NextStageStep (0);

	date = getDate ();
	// be sure options are before zones
	SCR::Write (.dns.named.section.options, "");

	boolean ok = true;
	foreach (`z, settings["zones"]:[], ``{
	    z["changed"] = true; // FIXME remove
	    ok = ok && saveZone (z);
	    Progress::NextStep ();
	});

	if(UI::PollInput() == `abort) return false;
	Progress::NextStageStep (zones);

	ok = ok &&saveGlobals ();
	if (! ok)
	    return false;

	if(UI::PollInput() == `abort) return false;
	Progress::NextStageStep (2 * zones);

	if (settings["__run_dhcp_server"]:false)
	{
	    integer ret = 0;
	    if (! write_only)
		ret = SCR::Execute (.target.bash, "/etc/init.d/named restart");
	    Runlevel::ServiceAdjust ("named", "enable");
	    if (0 != ret)
	    {
		// yes-no popup
		if (UI::YesNoPopup (_("Warning!

An error occured during starting of DNS server.
Display the log and continue with configuration?")))
		{
		    DnsServer::showLogPopup (nil);
		    return nil;
		}
		return false;
	    }
	}
	else
	{
	    SCR::Execute (.target.bash, "/etc/init.d/named stop");
	    Runlevel::ServiceAdjust ("named", "disable");
	}

	if(UI::PollInput() == `abort) return false;
	Progress::NextStageStep (3 * zones);

	// progress stage
        Progress::Title(_("Finished"));

	return true;
    }

/**
 * Get all dns-server settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global define boolean Import (map settings) ``{
    // TODO FIXME: your code here (fill the above mentioned variables)...
    sleep(3000);
    return true;
}

    /**
      * Dump the dns-server settings to a single map
      * (For use by autoinstallation.)
      * @return map Dumped settings (later acceptable by Import ())
      */
    global define map Export () ``{
	return settings;
    }

/**
 * Create a textual summary and a list of unconfigured cards
 * @param split split configured and unconfigured?
 * @return summary of the current configuration
 */
global define list Summary() ``{
    // TODO FIXME: your code here...
    return [ _("Configuration summary ..."), [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global define list Overview() ``{
    // TODO FIXME: your code here...
    return [];
}

/* EOF */
}
